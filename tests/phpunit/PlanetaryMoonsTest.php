<?php

declare(strict_types=1);

namespace Swisseph\Tests;

use PHPUnit\Framework\TestCase;
use Swisseph\Swe;
use Swisseph\Constants;
use Swisseph\State;
use Swisseph\SwephFile\SwedState;

/**
 * Tests for planetary moons (SE_PLMOON_OFFSET + moon_code)
 *
 * Reference values generated by C swetest64.exe at J2000.0 (JD 2451545.0 UT)
 * Command: swetest64.exe -b1.1.2000 -ut12:00 -pv -xv9501 -fPlbRs -head
 *
 * Moon ID format: 9PPP where PPP = planet*100 + moon_number
 * - 9401 = Phobos/Mars
 * - 9501 = Io/Jupiter
 * - 9502 = Europa/Jupiter
 * - 9606 = Titan/Saturn
 * - 9599 = Jupiter Center of Body (COB)
 */
class PlanetaryMoonsTest extends TestCase
{
    private const EPHE_PATH = 'C:\\Users\\serge\\OneDrive\\Documents\\Fractal\\Projects\\Component\\Swisseph\\eph\\ephe';
    private const JD_UT_J2000 = 2451545.0;

    // Reference values from C swetest64.exe for J2000.0 (JD 2451545.0 UT)
    // These are ecliptic geocentric apparent positions
    private const REF_IO = [
        'lon' => 25.2453334345,
        'lat' => -1.2606643530,
        'dist' => 4.623900795604097,
    ];

    private const REF_EUROPA = [
        'lon' => 25.2486798318,
        'lat' => -1.2648562866,
        'dist' => 4.616735688645866,
    ];

    private const REF_TITAN = [
        'lon' => 40.4487936293,
        'lat' => -2.4590445129,
        'dist' => 8.651526056163984,
    ];

    private const REF_JUPITER = [
        'lon' => 25.2530577103,
        'lat' => -1.2621945982,
        'dist' => 4.621163600880967,
    ];

    protected function setUp(): void
    {
        parent::setUp();
        State::setEphePath(self::EPHE_PATH);
        SwedState::getInstance()->setEphePath(self::EPHE_PATH);
    }

    public function testIoEclipticGeocentric(): void
    {
        $xx = [];
        $serr = null;
        $iflag = Constants::SEFLG_SWIEPH | Constants::SEFLG_SPEED;

        $ret = Swe::swe_calc(self::JD_UT_J2000, 9501, $iflag, $xx, $serr);

        $this->assertGreaterThanOrEqual(0, $ret, "swe_calc failed: $serr");
        $this->assertEqualsWithDelta(self::REF_IO['lon'], $xx[0], 0.0001, 'Io longitude');
        $this->assertEqualsWithDelta(self::REF_IO['lat'], $xx[1], 0.0001, 'Io latitude');
        $this->assertEqualsWithDelta(self::REF_IO['dist'], $xx[2], 0.0001, 'Io distance');
    }

    public function testIoEquatorial(): void
    {
        $xx = [];
        $serr = null;
        $iflag = Constants::SEFLG_SWIEPH | Constants::SEFLG_SPEED | Constants::SEFLG_EQUATORIAL;

        $ret = Swe::swe_calc(self::JD_UT_J2000, 9501, $iflag, $xx, $serr);

        $this->assertGreaterThanOrEqual(0, $ret, "swe_calc failed: $serr");
        // Reference: RA = 23.8599928368, Dec = 8.5928625014 from C test
        $this->assertEqualsWithDelta(23.8599928368, $xx[0], 0.0001, 'Io RA');
        $this->assertEqualsWithDelta(8.5928625014, $xx[1], 0.0001, 'Io Dec');
    }

    public function testIoTruepos(): void
    {
        $xx = [];
        $serr = null;
        $iflag = Constants::SEFLG_SWIEPH | Constants::SEFLG_SPEED | Constants::SEFLG_TRUEPOS;

        $ret = Swe::swe_calc(self::JD_UT_J2000, 9501, $iflag, $xx, $serr);

        $this->assertGreaterThanOrEqual(0, $ret, "swe_calc failed: $serr");
        // Reference: lon = 25.2496966032 (no light-time), lat = -1.2604133397, dist = 4.623909779522016
        $this->assertEqualsWithDelta(25.2496966032, $xx[0], 0.0001, 'Io TRUEPOS longitude');
        $this->assertEqualsWithDelta(-1.2604133397, $xx[1], 0.0001, 'Io TRUEPOS latitude');
        $this->assertEqualsWithDelta(4.623909779522016, $xx[2], 0.0001, 'Io TRUEPOS distance');
    }

    public function testIoBarycentric(): void
    {
        $xx = [];
        $serr = null;
        $iflag = Constants::SEFLG_SWIEPH | Constants::SEFLG_SPEED | Constants::SEFLG_BARYCTR;

        $ret = Swe::swe_calc(self::JD_UT_J2000, 9501, $iflag, $xx, $serr);

        $this->assertGreaterThanOrEqual(0, $ret, "swe_calc failed: $serr");
        // Reference: lon = 36.2975609614, lat = -1.1726596078, dist = 4.960527354209367
        $this->assertEqualsWithDelta(36.2975609614, $xx[0], 0.0001, 'Io barycentric longitude');
        $this->assertEqualsWithDelta(-1.1726596078, $xx[1], 0.0001, 'Io barycentric latitude');
        $this->assertEqualsWithDelta(4.960527354209367, $xx[2], 0.0001, 'Io barycentric distance');
    }

    public function testIoXyz(): void
    {
        $xx = [];
        $serr = null;
        $iflag = Constants::SEFLG_SWIEPH | Constants::SEFLG_SPEED | Constants::SEFLG_XYZ;

        $ret = Swe::swe_calc(self::JD_UT_J2000, 9501, $iflag, $xx, $serr);

        $this->assertGreaterThanOrEqual(0, $ret, "swe_calc failed: $serr");
        // Reference: X = 4.181259178325982, Y = 1.971593568218517, Z = -0.101730295449864
        $this->assertEqualsWithDelta(4.181259178325982, $xx[0], 0.0001, 'Io X');
        $this->assertEqualsWithDelta(1.971593568218517, $xx[1], 0.0001, 'Io Y');
        $this->assertEqualsWithDelta(-0.101730295449864, $xx[2], 0.0001, 'Io Z');
    }

    public function testEuropaEclipticGeocentric(): void
    {
        $xx = [];
        $serr = null;
        $iflag = Constants::SEFLG_SWIEPH | Constants::SEFLG_SPEED;

        $ret = Swe::swe_calc(self::JD_UT_J2000, 9502, $iflag, $xx, $serr);

        $this->assertGreaterThanOrEqual(0, $ret, "swe_calc failed: $serr");
        $this->assertEqualsWithDelta(self::REF_EUROPA['lon'], $xx[0], 0.001, 'Europa longitude');
        $this->assertEqualsWithDelta(self::REF_EUROPA['lat'], $xx[1], 0.001, 'Europa latitude');
        $this->assertEqualsWithDelta(self::REF_EUROPA['dist'], $xx[2], 0.001, 'Europa distance');
    }

    /**
     * Test Titan (Saturn's moon 9606) ecliptic geocentric
     * Reference values from C swetest64.exe test_io_debug
     */
    public function testTitanEclipticGeocentric(): void
    {
        $xx = [];
        $serr = null;
        $iflag = Constants::SEFLG_SWIEPH | Constants::SEFLG_SPEED;

        $ret = Swe::swe_calc(self::JD_UT_J2000, 9606, $iflag, $xx, $serr);

        $this->assertGreaterThanOrEqual(0, $ret, "swe_calc failed: $serr");
        $this->assertEqualsWithDelta(self::REF_TITAN['lon'], $xx[0], 0.001, 'Titan longitude');
        $this->assertEqualsWithDelta(self::REF_TITAN['lat'], $xx[1], 0.001, 'Titan latitude');
        $this->assertEqualsWithDelta(self::REF_TITAN['dist'], $xx[2], 0.001, 'Titan distance');
    }

    /**
     * Test that Io position is very close to Jupiter (within ~0.01 degrees)
     * since Io orbits very close to Jupiter
     */
    public function testIoNearJupiter(): void
    {
        $xxIo = [];
        $xxJup = [];
        $serr = null;
        $iflag = Constants::SEFLG_SWIEPH | Constants::SEFLG_SPEED;

        Swe::swe_calc(self::JD_UT_J2000, 9501, $iflag, $xxIo, $serr);
        Swe::swe_calc(self::JD_UT_J2000, Constants::SE_JUPITER, $iflag, $xxJup, $serr);

        // Io should be within 0.1 degrees of Jupiter in longitude
        $lonDiff = abs($xxIo[0] - $xxJup[0]);
        $this->assertLessThan(0.1, $lonDiff, 'Io should be within 0.1° of Jupiter in longitude');

        // Io should be within 0.1 degrees of Jupiter in latitude
        $latDiff = abs($xxIo[1] - $xxJup[1]);
        $this->assertLessThan(0.1, $latDiff, 'Io should be within 0.1° of Jupiter in latitude');

        // Io distance should be close to Jupiter (within 0.1 AU)
        $distDiff = abs($xxIo[2] - $xxJup[2]);
        $this->assertLessThan(0.1, $distDiff, 'Io should be within 0.1 AU of Jupiter');
    }

    /**
     * Test that non-existent moon returns error or handles gracefully
     * Note: behavior may vary depending on file availability
     */
    public function testInvalidMoonNumber(): void
    {
        $xx = [];
        $serr = null;
        $iflag = Constants::SEFLG_SWIEPH | Constants::SEFLG_SPEED;

        // 9999 is not a valid moon (would need ephemeris file sepm9999.se1)
        // We just check that it doesn't crash - it may return error or cached data
        $ret = Swe::swe_calc(self::JD_UT_J2000, 9999, $iflag, $xx, $serr);

        // Either an error (< 0) or some valid return is acceptable
        // Main goal is to ensure no crash
        $this->assertTrue($ret !== null, 'swe_calc should return a value for invalid moon');
    }

    /**
     * Test planetary moon names
     * Reference: C swetest64.exe swe_get_planet_name() output
     */
    public function testPlanetaryMoonNames(): void
    {
        // Io/Jupiter
        $name = \swe_get_planet_name(9501);
        $this->assertEquals('Io/Jupiter', $name, 'Io should be named "Io/Jupiter"');

        // Europa/Jupiter
        $name = \swe_get_planet_name(9502);
        $this->assertEquals('Europa/Jupiter', $name, 'Europa should be named "Europa/Jupiter"');

        // Titan/Saturn
        $name = \swe_get_planet_name(9606);
        $this->assertEquals('Titan/Saturn', $name, 'Titan should be named "Titan/Saturn"');
    }
}
