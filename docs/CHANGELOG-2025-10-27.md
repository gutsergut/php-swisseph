# Changelog — 27 октября 2025

## Добавлены утилитные функции для работы с углами

### Новые функции API (5 шт.)

#### 1. `swe_degnorm(float $x): float`
Нормализация угла в градусах к диапазону [0, 360).

**Примеры:**
```php
swe_degnorm(0.0);    // 0.0
swe_degnorm(360.0);  // 0.0
swe_degnorm(361.0);  // 1.0
swe_degnorm(-1.0);   // 359.0
swe_degnorm(-90.0);  // 270.0
```

#### 2. `swe_radnorm(float $x): float`
Нормализация угла в радианах к диапазону [0, 2π).

**Примеры:**
```php
swe_radnorm(0.0);           // 0.0
swe_radnorm(2 * M_PI);      // 0.0
swe_radnorm(-M_PI / 2);     // 3π/2
swe_radnorm(9 * M_PI / 4);  // π/4
```

#### 3. `swe_deg_midp(float $x1, float $x0): float`
Вычисление средней точки между двумя углами в градусах (по кратчайшей дуге).

**Примеры:**
```php
swe_deg_midp(90.0, 0.0);    // 45.0
swe_deg_midp(10.0, 350.0);  // 0.0 (через меридиан)
swe_deg_midp(170.0, 190.0); // 180.0
```

#### 4. `swe_rad_midp(float $x1, float $x0): float`
Вычисление средней точки между двумя углами в радианах (по кратчайшей дуге).

**Примеры:**
```php
swe_rad_midp(M_PI / 2, 0.0);  // π/4
swe_rad_midp(M_PI, 0.0);       // π/2
```

#### 5. `swe_split_deg(float $ddeg, int $roundflag, int &$ideg, int &$imin, int &$isec, float &$dsecfr, int &$isgn): void`
Разбиение десятичных градусов на компоненты: градусы, минуты, секунды, доли секунд и знак.

**Параметры:**
- `$ddeg` — десятичные градусы
- `$roundflag` — флаги округления и формата (см. константы ниже)
- `$ideg` — (выход) градусы (0-360 или 0-30 в зодиакальном режиме)
- `$imin` — (выход) минуты (0-59)
- `$isec` — (выход) секунды (0-59)
- `$dsecfr` — (выход) доли секунд
- `$isgn` — (выход) знак (+1 или -1)

**Примеры:**
```php
// Простое разбиение 45.5° = 45°30'00"
$d = $m = $s = $sgn = 0; $f = 0.0;
swe_split_deg(45.5, 0, $d, $m, $s, $f, $sgn);
// $d=45, $m=30, $s=0, $f=0.0, $sgn=1

// Зодиакальный формат: 123.5° = 3°30' Cnc (4-й знак)
swe_split_deg(123.5, SE_SPLIT_DEG_ZODIACAL, $d, $m, $s, $f, $sgn);
// $d=3, $m=30 (градус внутри знака)

// С округлением до минут
swe_split_deg(123.456789, SE_SPLIT_DEG_ROUND_MIN, $d, $m, $s, $f, $sgn);
// $d=123, $m=27, $s=0, $f=0.0
```

### Новые константы (7 шт.)

Для использования с `swe_split_deg()`:

| Константа | Значение | Описание |
|-----------|----------|----------|
| `SE_SPLIT_DEG_ROUND_SEC` | 1 | Округлить до секунд |
| `SE_SPLIT_DEG_ROUND_MIN` | 2 | Округлить до минут |
| `SE_SPLIT_DEG_ROUND_DEG` | 4 | Округлить до градусов |
| `SE_SPLIT_DEG_ZODIACAL` | 8 | Зодиакальный формат (0-30° внутри знака) |
| `SE_SPLIT_DEG_NAKSHATRA` | 1024 | Формат накшатр |
| `SE_SPLIT_DEG_KEEP_SIGN` | 16 | Не округлять до следующего знака |
| `SE_SPLIT_DEG_KEEP_DEG` | 32 | Не округлять до следующего градуса |

**Флаги можно комбинировать через OR:**
```php
$flags = SE_SPLIT_DEG_ZODIACAL | SE_SPLIT_DEG_ROUND_MIN;
swe_split_deg(123.456, $flags, $d, $m, $s, $f, $sgn);
```

### Внутренние реализации

#### Новые методы в классе `Math`:

1. **`Math::degMidpoint(float $x1, float $x0): float`**
   - Вычисление средней точки в градусах
   - Учитывает циклическую природу углов (переход через 0°/360°)
   - Всегда выбирает кратчайшую дугу

2. **`Math::radMidpoint(float $x1, float $x0): float`**
   - Вычисление средней точки в радианах
   - Учитывает циклическую природу углов (переход через 0/2π)
   - Всегда выбирает кратчайшую дугу

3. **`Math::splitDeg(float $ddeg, int $roundflag, int &$ideg, int &$imin, int &$isec, float &$dsecfr, int &$isgn): void`**
   - Полная реализация разбора градусов
   - Поддержка всех режимов округления
   - Поддержка зодиакального формата
   - Обработка отрицательных углов

### Тестирование

#### Создан `tests/phpunit/MathUtilsTest.php`:
- **9 тестов**, **58 assertions**
- Покрытие:
  - Нормализация углов (положительные, отрицательные, >360°, циклы)
  - Средние точки (обычные случаи, переход через 0°/360°, идентичные углы)
  - Разбор градусов (простой, с округлением до сек/мин/град, зодиакальный формат)

#### Все тесты проходят:
```
Math Utils
 ✔ Degnorm
 ✔ Radnorm
 ✔ Deg midpoint
 ✔ Rad midpoint
 ✔ Split deg simple
 ✔ Split deg round sec
 ✔ Split deg round min
 ✔ Split deg round deg
 ✔ Split deg zodiacal
```

### Совместимость с Swiss Ephemeris C API

Все функции полностью совместимы с оригинальным C API:
- Сигнатуры функций идентичны
- Поведение и результаты соответствуют C-коду
- Константы имеют те же значения

### Статистика проекта

#### До изменений:
- Функций API: 35
- Тестов: 76
- Assertions: 608

#### После изменений:
- **Функций API: 40** (+5)
- **Тестов: 85** (+9)
- **Assertions: 666** (+58)
- **Не реализовано: 49** (было 54)

### Обновлённые файлы

1. **`src/functions.php`** — добавлены 5 глобальных функций `swe_*`
2. **`src/Math.php`** — добавлены 3 статических метода
3. **`src/Constants.php`** — добавлены 7 констант `SE_SPLIT_DEG_*`
4. **`tests/phpunit/MathUtilsTest.php`** — создан новый тест
5. **`docs/ROADMAP.md`** — обновлён статус реализации

### Технические детали

#### Алгоритм `degMidpoint` / `radMidpoint`:
1. Нормализация обоих углов к [0, 360) / [0, 2π)
2. Вычисление наименьшей разности углов через `angleDiff`
3. Добавление половины разности к первому углу
4. Нормализация результата

#### Алгоритм `splitDeg`:
1. Определение знака (±1)
2. Работа с абсолютным значением
3. Применение зодиакального формата (mod 30) если нужно
4. Разбиение: градусы → минуты → секунды → доли
5. Применение округления (секунды/минуты/градусы)
6. Обработка переполнений (60" → 1', 60' → 1°)

### Следующие шаги

Приоритетные направления для дальнейшей работы:
1. Добавить функции календаря (`swe_date_conversion`, `swe_day_of_week`) — **✅ DONE**
2. Реализовать `swe_pheno` / `swe_pheno_ut` (фаза, блеск, угловой диаметр)
3. Добавить `swe_fixstar` для работы со звёздными каталогами
4. Расширить поддержку флагов в `swe_rise_trans` (twilight, disc center/bottom)
5. Улучшить точность узлов/апсид (координатные преобразования)

---

## Итерация 2: Календарные функции

### Добавлено 2 новые функции API

#### 1. `swe_date_conversion(int $y, int $m, int $d, float $utime, string $c, float &$tjd): int`
Преобразование календарной даты в Julian Day с валидацией.

**Параметры:**
- `$y` — год
- `$m` — месяц (1-12)
- `$d` — день (1-31)
- `$utime` — универсальное время в часах (десятичное, 0.0-23.999...)
- `$c` — тип календаря: `'g'` (Грегорианский) или `'j'` (Юлианский)
- `$tjd` — (выход) Julian Day

**Возвращает:** `SE_OK` (0) при успехе, `SE_ERR` (-1) при ошибке

**Валидация:**
- Проверка корректности месяца (1-12)
- Проверка дня месяца (включая високосные годы)
- Проверка времени (0.0 <= utime < 24.0)
- Проверка типа календаря ('g' или 'j')

**Примеры:**
```php
$tjd = 0.0;
$result = swe_date_conversion(2000, 1, 1, 12.0, 'g', $tjd);
// $result = SE_OK, $tjd ≈ 2451545.0 (J2000.0)

// Ошибка: Feb 30 не существует
$result = swe_date_conversion(2000, 2, 30, 0.0, 'g', $tjd);
// $result = SE_ERR

// Високосный год OK
$result = swe_date_conversion(2000, 2, 29, 0.0, 'g', $tjd);
// $result = SE_OK
```

#### 2. `swe_day_of_week(float $jd): int`
Вычисление дня недели для заданного Julian Day.

**Возвращает:** 0-6, где:
- 0 = Понедельник (Monday)
- 1 = Вторник (Tuesday)
- 2 = Среда (Wednesday)
- 3 = Четверг (Thursday)
- 4 = Пятница (Friday)
- 5 = Суббота (Saturday)
- 6 = Воскресенье (Sunday)

**Примеры:**
```php
// 2000-01-01 (Saturday)
$jd = swe_julday(2000, 1, 1, 0.0, SE_GREG_CAL);
$dow = swe_day_of_week($jd);
// $dow = 5 (Saturday)

// 2000-01-03 (Monday)
$jd = swe_julday(2000, 1, 3, 0.0, SE_GREG_CAL);
$dow = swe_day_of_week($jd);
// $dow = 0 (Monday)

// 2025-10-27 (Monday)
$jd = swe_julday(2025, 10, 27, 0.0, SE_GREG_CAL);
$dow = swe_day_of_week($jd);
// $dow = 0 (Monday)
```

### Реализовано в классах

#### Новые методы в классе `Julian`:

1. **`Julian::dateConversion(int $y, int $m, int $d, float $utime, string $c, float &$tjd): int`**
   - Полная валидация даты и времени
   - Обработка високосных лет (Грегорианских и Юлианских)
   - Проверка диапазонов дней для каждого месяца
   - Возврат кодов ошибок

2. **`Julian::dayOfWeek(float $jd): int`**
   - Формула: `((int)floor($jd + 0.5)) % 7`
   - JD 0.5 (полдень эпохи JD) = Monday
   - Циклическое повторение 0-6

### Тестирование

#### Создан `tests/phpunit/CalendarTest.php`:
- **7 тестов**, **33 assertions**
- Покрытие:
  - Валидные даты (Григорианские и Юлианские)
  - Високосные годы (2000, 2001)
  - Ошибки валидации: неверный месяц, день, время, тип календаря
  - День недели для известных дат
  - Циклическое повторение дней недели

#### Все тесты проходят:
```
Calendar
 ✔ Date conversion valid
 ✔ Date conversion invalid month
 ✔ Date conversion invalid day
 ✔ Date conversion invalid time
 ✔ Date conversion invalid calendar
 ✔ Day of week
 ✔ Day of week cycle
```

### Совместимость

Полная совместимость с Swiss Ephemeris C API:
- Сигнатуры идентичны оригинальным
- Валидация соответствует поведению C-кода
- День недели использует формулу из swephlib.c

### Обновлённая статистика

#### До изменений:
- Функций API: 40
- Тестов: 85
- Assertions: 666

#### После изменений:
- **Функций API: 42** (+2)
- **Тестов: 92** (+7)
- **Assertions: 699** (+33)
- **Не реализовано: 47** (было 49)

### Обновлённые файлы

1. **`src/Julian.php`** — добавлены 2 метода (`dateConversion`, `dayOfWeek`)
2. **`src/functions.php`** — добавлены 2 глобальные функции
3. **`tests/phpunit/CalendarTest.php`** — создан новый тест
4. **`docs/ROADMAP.md`** — обновлён список реализованных функций

### Исправленные баги

**Bug fix в `Julian::dayOfWeek()`:**
- Исходная формула: `(int)floor($jd + 1.5) % 7` — неверно
- Исправленная формула: `(int)floor($jd + 0.5) % 7` — правильно
- Причина: JD 0.5 = Monday, добавление 0.5 смещает к полуночи

---

**Всего за 2 итерации добавлено: 7 функций, 16 тестов, 91 assertion** ✨

---

## Итерация 3: Преобразования Local Mean Time ↔ Local Apparent Time

### Добавлено 2 новые функции API

#### 1. `swe_lmt_to_lat(float $tjd_lmt, float $geolon, float &$tjd_lat, ?string &$serr = null): int`
Преобразование Local Mean Time (среднее солнечное время) в Local Apparent Time (видимое солнечное время).

**Что такое LMT и LAT:**
- **LMT (Local Mean Time)** — локальное среднее солнечное время, основанное на фиктивном «среднем солнце», которое движется равномерно
- **LAT (Local Apparent Time)** — локальное видимое солнечное время, основанное на реальном положении Солнца
- **Equation of Time (E)** — разница между LAT и LMT, варьируется от -16 до +14 минут в течение года

**Формула:** `LAT = LMT + E`

**Параметры:**
- `$tjd_lmt` — Julian Day в Local Mean Time
- `$geolon` — географическая долгота (градусы, положительная к востоку)
- `$tjd_lat` — (выход) Julian Day в Local Apparent Time
- `$serr` — (выход) сообщение об ошибке

**Возвращает:** `SE_OK` (0) при успехе, `SE_ERR` (-1) при ошибке

**Примеры:**
```php
// Пример для Гринвича (lon=0°)
$tjd_lmt = 2451545.0; // J2000.0
$tjd_lat = 0.0;
$result = swe_lmt_to_lat($tjd_lmt, 0.0, $tjd_lat);
// LAT отличается от LMT на величину equation of time

// Для Москвы (lon ≈ 37.6°E)
$result = swe_lmt_to_lat($tjd_lmt, 37.6, $tjd_lat);
```

#### 2. `swe_lat_to_lmt(float $tjd_lat, float $geolon, float &$tjd_lmt, ?string &$serr = null): int`
Обратное преобразование: Local Apparent Time → Local Mean Time.

**Формула:** `LMT = LAT - E`

**Параметры:**
- `$tjd_lat` — Julian Day в Local Apparent Time
- `$geolon` — географическая долгота (градусы, положительная к востоку)
- `$tjd_lmt` — (выход) Julian Day в Local Mean Time
- `$serr` — (выход) сообщение об ошибке

**Возвращает:** `SE_OK` (0) при успехе, `SE_ERR` (-1) при ошибке

**Примеры:**
```php
$tjd_lat = 2451545.0;
$tjd_lmt = 0.0;
$result = swe_lat_to_lmt($tjd_lat, 0.0, $tjd_lmt);

// Проверка round-trip: LMT -> LAT -> LMT должно вернуть исходное значение
```

### Физический смысл Equation of Time

Equation of Time возникает из-за:
1. **Эллиптичности орбиты Земли** — Земля движется быстрее в перигелии (зимой) и медленнее в афелии (летом)
2. **Наклона оси Земли** — эклиптика наклонена к экватору на 23.4°

**Экстремумы E в 2000 году:**
- Около **11 февраля**: E ≈ -14 минут (солнечные часы отстают, LAT < LMT)
- Около **3 ноября**: E ≈ +16 минут (солнечные часы спешат, LAT > LMT)
- Четыре раза в год E = 0 (примерно 15 апр, 14 июн, 1 сен, 25 дек)

### Реализовано в классах

#### Расширен класс `TimeFunctions`:

1. **`TimeFunctions::lmtToLat(float $tjd_lmt, float $geolon, ?float &$tjd_lat, ?string &$serr): int`**
   - Преобразование LMT → UT (вычитание долготы)
   - Получение equation of time через `timeEqu()`
   - Добавление E к LMT: `LAT = LMT + E`

2. **`TimeFunctions::latToLmt(float $tjd_lat, float $geolon, ?float &$tjd_lmt, ?string &$serr): int`**
   - Преобразование LAT → UT (вычитание долготы)
   - Получение equation of time
   - Вычитание E из LAT: `LMT = LAT - E`

### Тестирование

#### Создан `tests/phpunit/TimeConversionTest.php`:
- **6 тестов**, **14 assertions**
- Покрытие:
  - Базовое преобразование LMT → LAT для Гринвича
  - Базовое преобразование LAT → LMT для Гринвича
  - Round-trip тест (LMT → LAT → LMT должно вернуть исходное значение)
  - Тесты с различными долготами (положительная/отрицательная)
  - Проверка знака equation of time в разные времена года

#### Все тесты проходят:
```
Time Conversion
 ✔ Lmt to lat basic
 ✔ Lat to lmt basic
 ✔ Lmt lat roundtrip
 ✔ Lmt to lat with longitude
 ✔ Lat to lmt with negative longitude
 ✔ Equation of time effect
```

### Совместимость

Полная совместимость с Swiss Ephemeris C API:
- Сигнатуры соответствуют оригинальным
- Использует ту же формулу equation of time из `swe_time_equ`
- Поведение идентично C-коду

### Обновлённая статистика

#### До изменений:
- Функций API: 42
- Тестов: 92
- Assertions: 699

#### После изменений:
- **Функций API: 44** (+2)
- **Тестов: 98** (+6)
- **Assertions: 713** (+14)
- **Не реализовано: 45** (было 47)

### Обновлённые файлы

1. **`src/Swe/Functions/TimeFunctions.php`** — добавлены 2 метода (`lmtToLat`, `latToLmt`)
2. **`src/functions.php`** — добавлены 2 глобальные функции
3. **`tests/phpunit/TimeConversionTest.php`** — создан новый тест
4. **`docs/ROADMAP.md`** — обновлён список реализованных функций

### Практическое применение

Эти функции полезны для:
- **Солнечных часов** — расчёт разницы между показаниями солнечных часов и обычных
- **Астрономических наблюдений** — определение истинного солнечного времени
- **Астрологии** — вычисление точного момента полудня по видимому Солнцу
- **Исторических расчётов** — многие старые документы используют LMT или LAT

---

**Всего за 3 итерации добавлено: 9 функций, 22 теста, 105 assertions** ✨
